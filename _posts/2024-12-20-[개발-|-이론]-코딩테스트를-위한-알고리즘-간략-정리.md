---
layout: post
date: 2024-12-20
title: "[개발 | 이론] 코딩테스트를 위한 알고리즘 간략 정리"
tags: [알고리즘, 이론, ]
categories: [백엔드, 이론, ]
mermaid: true
---



### 1. 브루트 포스(Brute Force) 완전 탐색 알고리즘


[https://www.youtube.com/watch?v=ZNa9-86uVEA&list=PLlV7zJmoG4XJMkxuBRgkpdX89tL6aXl6q](https://www.youtube.com/watch?v=ZNa9-86uVEA&list=PLlV7zJmoG4XJMkxuBRgkpdX89tL6aXl6q)


> 📌 비밀번호 해킹에서 많이 쓰는 무차별 대입 공격  
> - Brute → 단순히, 순전히 / Force → 힘

	- Brute → 단순히, 순전히 / Force → 힘

💡 주된 구현 방법

1. 단순 반복
2. 재귀를 통한 반복


### 2. 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS) 알고리즘


[https://www.youtube.com/watch?v=BsYbdUnKZ-Y&list=PLlV7zJmoG4XJMkxuBRgkpdX89tL6aXl6q&index=2](https://www.youtube.com/watch?v=BsYbdUnKZ-Y&list=PLlV7zJmoG4XJMkxuBRgkpdX89tL6aXl6q&index=2)


> 📌 넷플릭스에서 시리즈가 볼만 할까 찾는 과정을 예로 든다면  
> 1. 특정 시리즈 하나를 몰아 본다 = **DFS(Depth-First Search)**  
>   
> 2. 여러 개를 하나씩 본다 = **BFS(Breadth-First Search)**

	1. 특정 시리즈 하나를 몰아 본다 = **DFS(Depth-First Search)**
	2. 여러 개를 하나씩 본다 = **BFS(Breadth-First Search)**

DFS / BFS를 흔히 그래프 탐색 알고리즘이라 한다. 주로 그래프에서 특정 노드 A를 찾거나 특정 노드를 찾아가는 과정을 다룬다.

1. 경로탐색(최단거리, 시간)
2. 네트워크 유형(연결)
3. 조합 유형(모든 조합 만들기)


#### 깊이 우선 탐색(DFS) 구현


**DFS는 하나만 끝까지 탐색**하는 것이기 때문에 **재귀함수**를 사용해 구현하는게 일반적이다.

1. 탈출조건
2. 파라미터 조합

예제


![0](/assets/img/2024-12-20-개발--이론-코딩테스트를-위한-알고리즘-간략-정리.md/0.png)

1. 탈출조건 선정
2. 덧셈을 하나씩 조합하며 계산
3. 뺄셈을 하니씩 조합하며 계산


#### 너비 우선 탐색(**BFS) 구현**


BFS는 여러개를 한 번씩 탐색하는 것이기 때문에 주로 Queue / LinkedList를 사용해 구현된다.


예시 


![1](/assets/img/2024-12-20-개발--이론-코딩테스트를-위한-알고리즘-간략-정리.md/1.png)

1. 턴을 돌면서 가장 먼저 넣었던 것을 꺼낸다.
2. 연결된 점을 Queue에 넣는다.
3. Queue가 빌 때까지 반복

이렇게 순서가 중요하기 때문에 Queue나 LinkedList를 사용한다.



#### DFS나 BFS중 뭐가 더 좋을까?


둘다 용도는 비슷하기 때문에 손에 익는 것을 사용해라

1. 구현도 재귀함수로 단순하고 중간 중간 검증은 DFS가 더 쉬운게 일반적이다.

	→ 특히 코테의 경우 시간 싸움이기 때문에 디버깅이 쉬운 DFS가 편할 수 있다.

2. 깊이기 너무 깊어서 시간 초과가 발생할 수 있는 경우는 BFS를 사용해야 한다.

	→ 시간 복잡도가 더 낮다.


결국 둘다 구현할 줄 알아야 난이도 있는 코테에서 통과가 가능하다.



### 3. 해시(Hash) 알고리즘


> 📌 해시는 String를 기반으로 정보를 기록하고 관리해야 될때 사용한다.  
> - js는 Map 외에도 Object로도 사용이 가능하다.  
>   
> - 자바 기준 HashMap과 put / get / getOrDefalut 만 기억하자  
>   
> - js 기준 Map과 `set` / `get` / `??` 기억하자,  `forEach` 가능하다.

	- js는 Map 외에도 Object로도 사용이 가능하다.
	- 자바 기준 HashMap과 put / get / getOrDefalut 만 기억하자
	- js 기준 Map과 `set` / `get` / `??` 기억하자,  `forEach` 가능하다.
1. 완주하지 못한 선수
	1. 선수이름(key) → 완주 여부(value)
	2. `String key : bool Value`
2. 신고 결과 받기
	1. 신고당한 게시판 사용자(key) → 신고자들의 목록을 관리(value)
	2. `String key : ArrayList<String> value`
3. 위장 - 옷의 종류에 따라 몇개의 옵션 있는지 관리
	- 옷의 종류(key) → 옵션 몇개(value)
	- `String key : Integer value`


### 4. 문자열(String) 알고리즘



#### 문자열 단순 구현 유형


요구사항에 따라 단순 구현을 하는 문제로 String 관련 함수를 잘 이해하고 있으면 쉽게 풀 수 있다.

- ex) 규칙에 따른 ID 생성기


#### 문자열 + 특정 알고리즘 혼합 유형


단순 String 함수를 기반으로 Hash, 정렬, DFS 등의 알고리즘을 접목해야 풀이가 가능하다. 

- ex) 신고결과 받기
	- 문자열 parsing → indexOf + substring + 해시 알고리즘 접목
- 점점 많아지는 추세이다.
- 네카라쿠베 1번 문제에 주로 나온다.


### 5. 다이나믹 프로그래밍(DP) 알고리즘


[https://youtube.com/watch?v=0bqfTzpWySY&list=PLlV7zJmoG4XJOSotNY8Fm3FES6c2y4gTy](https://youtube.com/watch?v=0bqfTzpWySY&list=PLlV7zJmoG4XJOSotNY8Fm3FES6c2y4gTy)


> 📌 메모리를 사용해서 중복연산을 줄이고 중복 연산을 줄여서 수행 속도를 개선한다.  
> - DP라는 말이 적합하지 않다고 판단한 어떤 교수님은 DP를 “기억하기 알고리즘”, “기억하며 풀기”로 정의했다고 한다.

	- DP라는 말이 적합하지 않다고 판단한 어떤 교수님은 DP를 “기억하기 알고리즘”, “기억하며 풀기”로 정의했다고 한다.

중복 연산을 줄인다. = 연산한 결과를 배열에 담아 저장해둔다.

- 주로 DFS / BFS 같은 알고리즘으로 풀기에는 너무 오래 걸리는 경우 사용된다.


#### 다이나믹 프로그래밍 문제를 알아보고 구분하는 방법

1. DFS / BFS로 풀수는 있지만 경우의 수가 너무 많은 경우
	- 설명자의 경우 500만개 정도를 DFS / BFS로 풀이가능한 최대라고 본다.
2. 경우의 수들에 중복적인 연산이 많은 경우
	- 손으로 한 번 풀어보며 중복 연산 패턴을 찾아보는 것을 추천하신다.
3. 문제 해결 접근 방법
	- 최대한 많은 문제를 풀어보고, 풀이를 참고하며 **DP적 사고를 만들어야 한다.**
	- 이 문제의 경우 30분 고민해보고 답이안나오면 도움을 받는게 좋다.
	- **그 30분 동안은 어떻게 하면 연산을 줄일 수 있을까를 고민한다.**
		- 어떤 정보를 남기지?, 어떤 정보를 누적해야 할까?
		- 여태 까지의 최적의 답을 쌓아가는 방식으로 접근해야한다.


### 6. 탐욕(Greedy) 알고리즘


> 📌 미래를 고려하지 않고 오직 **현재 시점의 최선을 선택한다.**

- 미래에 어떤 부수효과를 낳을지 고려하지 않고 현재의 가장 빠른, 비용이 낮은 최선의 선택을 한다. (aka 상남자 알고리즘, 경주마 알고리즘)
- **현재 내릴 수 있는 최선의 선택에만 집중한다.**


#### 그리디 알고리즘의 특징


> 💡 미래의 선택을 고려하지 않고, 현재만 충실한게 최적의 해가 될 수 있을까?


그리디 알고리즘은 **최적의 해를 보장하는 알고리즘이 아니다.**
현재의 최적의 해 ≠ 미래의 최적의 해 아니기 때문에 근사 알고리즘이라고 하기도 한다.


이러한 특징 때문에 코테에서 그리디 알고리즘을 사용하려면 조건이 존재한다.

- 현재의 선택이 미래의 선택에 영향을 주지 않는다.
- 부분의 최적의 해가 모이면 전체의 최적의 해가 된다.

**이러한 조건이 충족할 때 현재의 최적의 해가 미래에도 최적의 해라고 할 수 있다.**



#### **현재의 선택이 미래의 선택에 영향을 주지 않는다.**


아래 문제 하나가 있다. “서울에서 대전을 경유해 부산을 가는 최적의 경로를 구하라”


![2](/assets/img/2024-12-20-개발--이론-코딩테스트를-위한-알고리즘-간략-정리.md/2.png)


이때 서울에서 대전까지의 경로가 대전에서 부산까지의 경로에 영향을 줄까? 


당연히 영향을 주지 않는다 **즉, 현재의 대전까지 경로 선택이 미래의 부산까지 경로 선택에 영향을 주지 않는 이런 경우에 그리디 알고리즘을 사용하는게 적합하다.**


이러한 것을 ‘탐욕스런 선택 조건(Greedy Choice Property)’라 한다.



#### 부분의 최적의 해가 모이면 전체의 최적의 해가 된다.


![3](/assets/img/2024-12-20-개발--이론-코딩테스트를-위한-알고리즘-간략-정리.md/3.png)


위와 같은 문제를 예시로 보자. 


이 문제는 결국 ‘서울에서 대전까지 최소거리 + 대전에서 부산까지 최소거리’ 이다.


즉, 하나의 큰 문제를 여러개의 작은 문제로 나눌 수 있고 그 작은 문제들에 대한 최적의 해가 더해지는 것이 곧 전체 구조의 최적의 해가 되는 구조이다.


이것을 ‘최적 부분 구조 조건(Optimal Substructure)’라 한다.



#### 그리디 전략: 그러면 문제에 어떻게 적용해야 할까?


이 문제의 핵심은 정렬이다. 즉, 어떻게 정렬해야 위 두가지 조건을 만족할 수 있을까.


**다른 말로 어떻게 정렬해야 미래의 선택은 따져보지 않고 현재만 고려해도 최적의 해를 구할 수 있을까? 라는 답을 찾아야 한다.**

- 회의실 배정(백준 1931)


#### 그리디 알고리즘 왜 쓸까?


이것도 다이나믹 프로그래밍 알고리즘 처럼 적용하기 쉽지 않다. 그럼에도 사용하는 이유는 속도 때문이다.


속도를 위해 발전된 양상

- 완전 탐색 → 다이나믹 프로그래밍 → 그리디

현실에서는 완벽하지 않아도 근사치만 나와도 괜찮은 경우에 주로 사용한다.


예를 들어 네비게이션을 보자 모든 경로를 고려한 최단 최적의 길안내를 받으려면 네비 검색 한 번에 너무 오랜 시간이 걸린다. 그렇기 때문에 어느 정도 오차는 감수하고 근접한 최적의 경로를 추천한다.

